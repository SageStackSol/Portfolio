{"ast":null,"code":"\"use client\";\n\nvar _jsxFileName = \"/Users/Hemanth/monke matrix projects/sage-stack/src/components/cursor/SplashCursor.jsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction SplashCursor({\n  SIM_RESOLUTION = 128,\n  DYE_RESOLUTION = 1440,\n  CAPTURE_RESOLUTION = 512,\n  DENSITY_DISSIPATION = 3.5,\n  VELOCITY_DISSIPATION = 2,\n  PRESSURE = 0.1,\n  PRESSURE_ITERATIONS = 20,\n  CURL = 3,\n  SPLAT_RADIUS = 0.2,\n  SPLAT_FORCE = 6000,\n  SHADING = true,\n  COLOR_UPDATE_SPEED = 10,\n  // BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n  TRANSPARENT = true\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    function pointerPrototype() {\n      this.id = -1;\n      this.texcoordX = 0;\n      this.texcoordY = 0;\n      this.prevTexcoordX = 0;\n      this.prevTexcoordY = 0;\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.down = false;\n      this.moved = false;\n      this.color = [0, 0, 0];\n    }\n    let config = {\n      SIM_RESOLUTION,\n      DYE_RESOLUTION,\n      CAPTURE_RESOLUTION,\n      DENSITY_DISSIPATION,\n      VELOCITY_DISSIPATION,\n      PRESSURE,\n      PRESSURE_ITERATIONS,\n      CURL,\n      SPLAT_RADIUS,\n      SPLAT_FORCE,\n      SHADING,\n      COLOR_UPDATE_SPEED,\n      PAUSED: false,\n      BACK_COLOR,\n      TRANSPARENT\n    };\n    let pointers = [new pointerPrototype()];\n    const {\n      gl,\n      ext\n    } = getWebGLContext(canvas);\n    if (!ext.supportLinearFiltering) {\n      config.DYE_RESOLUTION = 256;\n      config.SHADING = false;\n    }\n    function getWebGLContext(canvas) {\n      const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false\n      };\n      let gl = canvas.getContext(\"webgl2\", params);\n      const isWebGL2 = !!gl;\n      if (!isWebGL2) gl = canvas.getContext(\"webgl\", params) || canvas.getContext(\"experimental-webgl\", params);\n      let halfFloat;\n      let supportLinearFiltering;\n      if (isWebGL2) {\n        gl.getExtension(\"EXT_color_buffer_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n      } else {\n        halfFloat = gl.getExtension(\"OES_texture_half_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_half_float_linear\");\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;\n      let formatRGBA;\n      let formatRG;\n      let formatR;\n      if (isWebGL2) {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n      } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      }\n      return {\n        gl,\n        ext: {\n          formatRGBA,\n          formatRG,\n          formatR,\n          halfFloatTexType,\n          supportLinearFiltering\n        }\n      };\n    }\n    function getSupportedFormat(gl, internalFormat, format, type) {\n      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch (internalFormat) {\n          case gl.R16F:\n            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n          case gl.RG16F:\n            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n          default:\n            return null;\n        }\n      }\n      return {\n        internalFormat,\n        format\n      };\n    }\n    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      return status === gl.FRAMEBUFFER_COMPLETE;\n    }\n    class Material {\n      constructor(vertexShader, fragmentShaderSource) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n      }\n      setKeywords(keywords) {\n        let hash = 0;\n        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n          let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);\n          program = createProgram(this.vertexShader, fragmentShader);\n          this.programs[hash] = program;\n        }\n        if (program === this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n      }\n      bind() {\n        gl.useProgram(this.activeProgram);\n      }\n    }\n    class Program {\n      constructor(vertexShader, fragmentShader) {\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n      }\n      bind() {\n        gl.useProgram(this.program);\n      }\n    }\n    function createProgram(vertexShader, fragmentShader) {\n      let program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));\n      return program;\n    }\n    function getUniforms(program) {\n      let uniforms = [];\n      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n      }\n      return uniforms;\n    }\n    function compileShader(type, source, keywords) {\n      source = addKeywords(source, keywords);\n      const shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));\n      return shader;\n    }\n    function addKeywords(source, keywords) {\n      if (!keywords) return source;\n      let keywordsString = \"\";\n      keywords.forEach(keyword => {\n        keywordsString += \"#define \" + keyword + \"\\n\";\n      });\n      return keywordsString + source;\n    }\n    const baseVertexShader = compileShader(gl.VERTEX_SHADER, `\n        precision highp float;\n        attribute vec2 aPosition;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform vec2 texelSize;\n\n        void main () {\n            vUv = aPosition * 0.5 + 0.5;\n            vL = vUv - vec2(texelSize.x, 0.0);\n            vR = vUv + vec2(texelSize.x, 0.0);\n            vT = vUv + vec2(0.0, texelSize.y);\n            vB = vUv - vec2(0.0, texelSize.y);\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `);\n    const copyShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n\n        void main () {\n            gl_FragColor = texture2D(uTexture, vUv);\n        }\n      `);\n    const clearShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform float value;\n\n        void main () {\n            gl_FragColor = value * texture2D(uTexture, vUv);\n        }\n     `);\n    const displayShaderSource = `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    `;\n    const splatShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uTarget;\n        uniform float aspectRatio;\n        uniform vec3 color;\n        uniform vec2 point;\n        uniform float radius;\n\n        void main () {\n            vec2 p = vUv - point.xy;\n            p.x *= aspectRatio;\n            vec3 splat = exp(-dot(p, p) / radius) * color;\n            vec3 base = texture2D(uTarget, vUv).xyz;\n            gl_FragColor = vec4(base + splat, 1.0);\n        }\n      `);\n    const advectionShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uSource;\n        uniform vec2 texelSize;\n        uniform vec2 dyeTexelSize;\n        uniform float dt;\n        uniform float dissipation;\n\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n            vec2 st = uv / tsize - 0.5;\n            vec2 iuv = floor(st);\n            vec2 fuv = fract(st);\n\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n        }\n\n        void main () {\n            #ifdef MANUAL_FILTERING\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n            #else\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n                vec4 result = texture2D(uSource, coord);\n            #endif\n            float decay = 1.0 + dissipation * dt;\n            gl_FragColor = result / decay;\n        }\n      `, ext.supportLinearFiltering ? null : [\"MANUAL_FILTERING\"]);\n    const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).x;\n            float R = texture2D(uVelocity, vR).x;\n            float T = texture2D(uVelocity, vT).y;\n            float B = texture2D(uVelocity, vB).y;\n\n            vec2 C = texture2D(uVelocity, vUv).xy;\n            if (vL.x < 0.0) { L = -C.x; }\n            if (vR.x > 1.0) { R = -C.x; }\n            if (vT.y > 1.0) { T = -C.y; }\n            if (vB.y < 0.0) { B = -C.y; }\n\n            float div = 0.5 * (R - L + T - B);\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n        }\n      `);\n    const curlShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).y;\n            float R = texture2D(uVelocity, vR).y;\n            float T = texture2D(uVelocity, vT).x;\n            float B = texture2D(uVelocity, vB).x;\n            float vorticity = R - L - T + B;\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n        }\n      `);\n    const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uCurl;\n        uniform float curl;\n        uniform float dt;\n\n        void main () {\n            float L = texture2D(uCurl, vL).x;\n            float R = texture2D(uCurl, vR).x;\n            float T = texture2D(uCurl, vT).x;\n            float B = texture2D(uCurl, vB).x;\n            float C = texture2D(uCurl, vUv).x;\n\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n            force /= length(force) + 0.0001;\n            force *= curl * C;\n            force.y *= -1.0;\n\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity += force * dt;\n            velocity = min(max(velocity, -1000.0), 1000.0);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `);\n    const pressureShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uDivergence;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            float C = texture2D(uPressure, vUv).x;\n            float divergence = texture2D(uDivergence, vUv).x;\n            float pressure = (L + R + B + T - divergence) * 0.25;\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n        }\n      `);\n    const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity.xy -= vec2(R - L, T - B);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `);\n    const blit = (() => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      return (target, clear = false) => {\n        if (target == null) {\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n          gl.viewport(0, 0, target.width, target.height);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      };\n    })();\n    let dye, velocity, divergence, curl, pressure;\n    const copyProgram = new Program(baseVertexShader, copyShader);\n    const clearProgram = new Program(baseVertexShader, clearShader);\n    const splatProgram = new Program(baseVertexShader, splatShader);\n    const advectionProgram = new Program(baseVertexShader, advectionShader);\n    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n    const curlProgram = new Program(baseVertexShader, curlShader);\n    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n    const pressureProgram = new Program(baseVertexShader, pressureShader);\n    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n    function initFramebuffers() {\n      let simRes = getResolution(config.SIM_RESOLUTION);\n      let dyeRes = getResolution(config.DYE_RESOLUTION);\n      const texType = ext.halfFloatTexType;\n      const rgba = ext.formatRGBA;\n      const rg = ext.formatRG;\n      const r = ext.formatR;\n      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n      gl.disable(gl.BLEND);\n      if (!dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);\n      if (!velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);\n      divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n      pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);\n    }\n    function createFBO(w, h, internalFormat, format, type, param) {\n      gl.activeTexture(gl.TEXTURE0);\n      let texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n      let fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n      gl.viewport(0, 0, w, h);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      let texelSizeX = 1.0 / w;\n      let texelSizeY = 1.0 / h;\n      return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id) {\n          gl.activeTexture(gl.TEXTURE0 + id);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          return id;\n        }\n      };\n    }\n    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n      return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read() {\n          return fbo1;\n        },\n        set read(value) {\n          fbo1 = value;\n        },\n        get write() {\n          return fbo2;\n        },\n        set write(value) {\n          fbo2 = value;\n        },\n        swap() {\n          let temp = fbo1;\n          fbo1 = fbo2;\n          fbo2 = temp;\n        }\n      };\n    }\n    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n      copyProgram.bind();\n      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n      blit(newFBO);\n      return newFBO;\n    }\n    function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n      if (target.width === w && target.height === h) return target;\n      target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);\n      target.write = createFBO(w, h, internalFormat, format, type, param);\n      target.width = w;\n      target.height = h;\n      target.texelSizeX = 1.0 / w;\n      target.texelSizeY = 1.0 / h;\n      return target;\n    }\n    function updateKeywords() {\n      let displayKeywords = [];\n      if (config.SHADING) displayKeywords.push(\"SHADING\");\n      displayMaterial.setKeywords(displayKeywords);\n    }\n    updateKeywords();\n    initFramebuffers();\n    let lastUpdateTime = Date.now();\n    let colorUpdateTimer = 0.0;\n    function updateFrame() {\n      const dt = calcDeltaTime();\n      if (resizeCanvas()) initFramebuffers();\n      updateColors(dt);\n      applyInputs();\n      step(dt);\n      render(null);\n      requestAnimationFrame(updateFrame);\n    }\n    function calcDeltaTime() {\n      let now = Date.now();\n      let dt = (now - lastUpdateTime) / 1000;\n      dt = Math.min(dt, 0.016666);\n      lastUpdateTime = now;\n      return dt;\n    }\n    function resizeCanvas() {\n      let width = scaleByPixelRatio(canvas.clientWidth);\n      let height = scaleByPixelRatio(canvas.clientHeight);\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n    function updateColors(dt) {\n      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n      if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach(p => {\n          p.color = generateColor();\n        });\n      }\n    }\n    function applyInputs() {\n      pointers.forEach(p => {\n        if (p.moved) {\n          p.moved = false;\n          splatPointer(p);\n        }\n      });\n    }\n    function step(dt) {\n      gl.disable(gl.BLEND);\n      curlProgram.bind();\n      gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(curl);\n      vorticityProgram.bind();\n      gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n      blit(velocity.write);\n      velocity.swap();\n      divergenceProgram.bind();\n      gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(divergence);\n      clearProgram.bind();\n      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n      blit(pressure.write);\n      pressure.swap();\n      pressureProgram.bind();\n      gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n        blit(pressure.write);\n        pressure.swap();\n      }\n      gradienSubtractProgram.bind();\n      gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));\n      gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));\n      blit(velocity.write);\n      velocity.swap();\n      advectionProgram.bind();\n      gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);\n      if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);\n      let velocityId = velocity.read.attach(0);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n      gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n      blit(velocity.write);\n      velocity.swap();\n      if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n      gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n      blit(dye.write);\n      dye.swap();\n    }\n    function render(target) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n      drawDisplay(target);\n    }\n    function drawDisplay(target) {\n      let width = target == null ? gl.drawingBufferWidth : target.width;\n      let height = target == null ? gl.drawingBufferHeight : target.height;\n      displayMaterial.bind();\n      if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n      blit(target);\n    }\n    function splatPointer(pointer) {\n      let dx = pointer.deltaX * config.SPLAT_FORCE;\n      let dy = pointer.deltaY * config.SPLAT_FORCE;\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n    }\n    function clickSplat(pointer) {\n      const color = generateColor();\n      color.r *= 10.0;\n      color.g *= 10.0;\n      color.b *= 10.0;\n      let dx = 10 * (Math.random() - 0.5);\n      let dy = 30 * (Math.random() - 0.5);\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n    }\n    function splat(x, y, dx, dy, color) {\n      splatProgram.bind();\n      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n      gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n      gl.uniform2f(splatProgram.uniforms.point, x, y);\n      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n      gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n      blit(velocity.write);\n      velocity.swap();\n      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n      blit(dye.write);\n      dye.swap();\n    }\n    function correctRadius(radius) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) radius *= aspectRatio;\n      return radius;\n    }\n    function updatePointerDownData(pointer, id, posX, posY) {\n      pointer.id = id;\n      pointer.down = true;\n      pointer.moved = false;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.deltaX = 0;\n      pointer.deltaY = 0;\n      pointer.color = generateColor();\n    }\n    function updatePointerMoveData(pointer, posX, posY, color) {\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n      pointer.color = color;\n    }\n    function updatePointerUpData(pointer) {\n      pointer.down = false;\n    }\n    function correctDeltaX(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio < 1) delta *= aspectRatio;\n      return delta;\n    }\n    function correctDeltaY(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) delta /= aspectRatio;\n      return delta;\n    }\n    function generateColor() {\n      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n      c.r *= 0.15;\n      c.g *= 0.15;\n      c.b *= 0.15;\n      return c;\n    }\n    function HSVtoRGB(h, s, v) {\n      let r, g, b, i, f, p, q, t;\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n        default:\n          break;\n      }\n      return {\n        r,\n        g,\n        b\n      };\n    }\n    function wrap(value, min, max) {\n      const range = max - min;\n      if (range === 0) return min;\n      return (value - min) % range + min;\n    }\n    function getResolution(resolution) {\n      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n      const min = Math.round(resolution);\n      const max = Math.round(resolution * aspectRatio);\n      if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {\n        width: max,\n        height: min\n      };else return {\n        width: min,\n        height: max\n      };\n    }\n    function scaleByPixelRatio(input) {\n      const pixelRatio = window.devicePixelRatio || 1;\n      return Math.floor(input * pixelRatio);\n    }\n    function hashCode(s) {\n      if (s.length === 0) return 0;\n      let hash = 0;\n      for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0;\n      }\n      return hash;\n    }\n    window.addEventListener(\"mousedown\", e => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      updatePointerDownData(pointer, -1, posX, posY);\n      clickSplat(pointer);\n    });\n    document.body.addEventListener(\"mousemove\", function handleFirstMouseMove(e) {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = generateColor();\n      updateFrame();\n      updatePointerMoveData(pointer, posX, posY, color);\n      document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n    });\n    window.addEventListener(\"mousemove\", e => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = pointer.color;\n      updatePointerMoveData(pointer, posX, posY, color);\n    });\n    document.body.addEventListener(\"touchstart\", function handleFirstTouchStart(e) {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updateFrame();\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n      document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n    });\n    window.addEventListener(\"touchstart\", e => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n    });\n    window.addEventListener(\"touchmove\", e => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerMoveData(pointer, posX, posY, pointer.color);\n      }\n    }, false);\n    window.addEventListener(\"touchend\", e => {\n      const touches = e.changedTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        updatePointerUpData(pointer);\n      }\n    });\n    updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [SIM_RESOLUTION, DYE_RESOLUTION, CAPTURE_RESOLUTION, DENSITY_DISSIPATION, VELOCITY_DISSIPATION, PRESSURE, PRESSURE_ITERATIONS, CURL, SPLAT_RADIUS, SPLAT_FORCE, SHADING, COLOR_UPDATE_SPEED, BACK_COLOR, TRANSPARENT]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      id: \"fluid\",\n      className: \"w-screen h-screen block\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1247,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1246,\n    columnNumber: 5\n  }, this);\n}\n_s(SplashCursor, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SplashCursor;\nexport default SplashCursor;\nvar _c;\n$RefreshReg$(_c, \"SplashCursor\");","map":{"version":3,"names":["_jsxFileName","_s","$RefreshSig$","useEffect","useRef","jsxDEV","_jsxDEV","SplashCursor","SIM_RESOLUTION","DYE_RESOLUTION","CAPTURE_RESOLUTION","DENSITY_DISSIPATION","VELOCITY_DISSIPATION","PRESSURE","PRESSURE_ITERATIONS","CURL","SPLAT_RADIUS","SPLAT_FORCE","SHADING","COLOR_UPDATE_SPEED","TRANSPARENT","canvasRef","canvas","current","pointerPrototype","id","texcoordX","texcoordY","prevTexcoordX","prevTexcoordY","deltaX","deltaY","down","moved","color","config","PAUSED","BACK_COLOR","pointers","gl","ext","getWebGLContext","supportLinearFiltering","params","alpha","depth","stencil","antialias","preserveDrawingBuffer","getContext","isWebGL2","halfFloat","getExtension","clearColor","halfFloatTexType","HALF_FLOAT","HALF_FLOAT_OES","formatRGBA","formatRG","formatR","getSupportedFormat","RGBA16F","RGBA","RG16F","RG","R16F","RED","internalFormat","format","type","supportRenderTextureFormat","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","fbo","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","status","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Material","constructor","vertexShader","fragmentShaderSource","programs","activeProgram","uniforms","setKeywords","keywords","hash","i","length","hashCode","program","fragmentShader","compileShader","FRAGMENT_SHADER","createProgram","getUniforms","bind","useProgram","Program","attachShader","linkProgram","getProgramParameter","LINK_STATUS","console","trace","getProgramInfoLog","uniformCount","ACTIVE_UNIFORMS","uniformName","getActiveUniform","name","getUniformLocation","source","addKeywords","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","keywordsString","forEach","keyword","baseVertexShader","VERTEX_SHADER","copyShader","clearShader","displayShaderSource","splatShader","advectionShader","divergenceShader","curlShader","vorticityShader","pressureShader","gradientSubtractShader","blit","bindBuffer","ARRAY_BUFFER","createBuffer","bufferData","Float32Array","STATIC_DRAW","ELEMENT_ARRAY_BUFFER","Uint16Array","vertexAttribPointer","FLOAT","enableVertexAttribArray","target","clear","viewport","drawingBufferWidth","drawingBufferHeight","width","height","COLOR_BUFFER_BIT","drawElements","TRIANGLES","UNSIGNED_SHORT","dye","velocity","divergence","curl","pressure","copyProgram","clearProgram","splatProgram","advectionProgram","divergenceProgram","curlProgram","vorticityProgram","pressureProgram","gradienSubtractProgram","displayMaterial","initFramebuffers","simRes","getResolution","dyeRes","texType","rgba","rg","r","filtering","LINEAR","disable","BLEND","createDoubleFBO","resizeDoubleFBO","createFBO","w","h","param","activeTexture","TEXTURE0","texelSizeX","texelSizeY","attach","fbo1","fbo2","read","value","write","swap","temp","resizeFBO","newFBO","uniform1i","uTexture","updateKeywords","displayKeywords","push","lastUpdateTime","Date","now","colorUpdateTimer","updateFrame","dt","calcDeltaTime","resizeCanvas","updateColors","applyInputs","step","render","requestAnimationFrame","Math","min","scaleByPixelRatio","clientWidth","clientHeight","wrap","p","generateColor","splatPointer","uniform2f","texelSize","uVelocity","uCurl","uniform1f","uDivergence","uPressure","dyeTexelSize","velocityId","uSource","dissipation","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","enable","drawDisplay","pointer","dx","dy","splat","clickSplat","g","b","random","x","y","uTarget","aspectRatio","point","uniform3f","radius","correctRadius","updatePointerDownData","posX","posY","updatePointerMoveData","correctDeltaX","correctDeltaY","abs","updatePointerUpData","delta","c","HSVtoRGB","s","v","f","q","t","floor","max","range","resolution","round","input","pixelRatio","window","devicePixelRatio","charCodeAt","addEventListener","e","clientX","clientY","document","body","handleFirstMouseMove","removeEventListener","handleFirstTouchStart","touches","targetTouches","identifier","changedTouches","className","children","ref","fileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/Hemanth/monke matrix projects/sage-stack/src/components/cursor/SplashCursor.jsx"],"sourcesContent":["\"use client\";\nimport { useEffect, useRef } from \"react\";\n\nfunction SplashCursor({\n  SIM_RESOLUTION = 128,\n  DYE_RESOLUTION = 1440,\n  CAPTURE_RESOLUTION = 512,\n  DENSITY_DISSIPATION = 3.5,\n  VELOCITY_DISSIPATION = 2,\n  PRESSURE = 0.1,\n  PRESSURE_ITERATIONS = 20,\n  CURL = 3,\n  SPLAT_RADIUS = 0.2,\n  SPLAT_FORCE = 6000,\n  SHADING = true,\n  COLOR_UPDATE_SPEED = 10,\n  // BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n  TRANSPARENT = true,\n}) {\n  const canvasRef = useRef(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    function pointerPrototype() {\n      this.id = -1;\n      this.texcoordX = 0;\n      this.texcoordY = 0;\n      this.prevTexcoordX = 0;\n      this.prevTexcoordY = 0;\n      this.deltaX = 0;\n      this.deltaY = 0;\n      this.down = false;\n      this.moved = false;\n      this.color = [0, 0, 0];\n    }\n\n    let config = {\n      SIM_RESOLUTION,\n      DYE_RESOLUTION,\n      CAPTURE_RESOLUTION,\n      DENSITY_DISSIPATION,\n      VELOCITY_DISSIPATION,\n      PRESSURE,\n      PRESSURE_ITERATIONS,\n      CURL,\n      SPLAT_RADIUS,\n      SPLAT_FORCE,\n      SHADING,\n      COLOR_UPDATE_SPEED,\n      PAUSED: false,\n      BACK_COLOR,\n      TRANSPARENT,\n    };\n\n    let pointers = [new pointerPrototype()];\n\n    const { gl, ext } = getWebGLContext(canvas);\n    if (!ext.supportLinearFiltering) {\n      config.DYE_RESOLUTION = 256;\n      config.SHADING = false;\n    }\n\n    function getWebGLContext(canvas) {\n      const params = {\n        alpha: true,\n        depth: false,\n        stencil: false,\n        antialias: false,\n        preserveDrawingBuffer: false,\n      };\n      let gl = canvas.getContext(\"webgl2\", params);\n      const isWebGL2 = !!gl;\n      if (!isWebGL2)\n        gl =\n          canvas.getContext(\"webgl\", params) ||\n          canvas.getContext(\"experimental-webgl\", params);\n      let halfFloat;\n      let supportLinearFiltering;\n      if (isWebGL2) {\n        gl.getExtension(\"EXT_color_buffer_float\");\n        supportLinearFiltering = gl.getExtension(\"OES_texture_float_linear\");\n      } else {\n        halfFloat = gl.getExtension(\"OES_texture_half_float\");\n        supportLinearFiltering = gl.getExtension(\n          \"OES_texture_half_float_linear\",\n        );\n      }\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      const halfFloatTexType = isWebGL2\n        ? gl.HALF_FLOAT\n        : halfFloat && halfFloat.HALF_FLOAT_OES;\n      let formatRGBA;\n      let formatRG;\n      let formatR;\n\n      if (isWebGL2) {\n        formatRGBA = getSupportedFormat(\n          gl,\n          gl.RGBA16F,\n          gl.RGBA,\n          halfFloatTexType,\n        );\n        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n      } else {\n        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n      }\n\n      return {\n        gl,\n        ext: {\n          formatRGBA,\n          formatRG,\n          formatR,\n          halfFloatTexType,\n          supportLinearFiltering,\n        },\n      };\n    }\n\n    function getSupportedFormat(gl, internalFormat, format, type) {\n      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n        switch (internalFormat) {\n          case gl.R16F:\n            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n          case gl.RG16F:\n            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n          default:\n            return null;\n        }\n      }\n      return {\n        internalFormat,\n        format,\n      };\n    }\n\n    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n      const texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        internalFormat,\n        4,\n        4,\n        0,\n        format,\n        type,\n        null,\n      );\n      const fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        texture,\n        0,\n      );\n      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n      return status === gl.FRAMEBUFFER_COMPLETE;\n    }\n\n    class Material {\n      constructor(vertexShader, fragmentShaderSource) {\n        this.vertexShader = vertexShader;\n        this.fragmentShaderSource = fragmentShaderSource;\n        this.programs = [];\n        this.activeProgram = null;\n        this.uniforms = [];\n      }\n      setKeywords(keywords) {\n        let hash = 0;\n        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n        let program = this.programs[hash];\n        if (program == null) {\n          let fragmentShader = compileShader(\n            gl.FRAGMENT_SHADER,\n            this.fragmentShaderSource,\n            keywords,\n          );\n          program = createProgram(this.vertexShader, fragmentShader);\n          this.programs[hash] = program;\n        }\n        if (program === this.activeProgram) return;\n        this.uniforms = getUniforms(program);\n        this.activeProgram = program;\n      }\n      bind() {\n        gl.useProgram(this.activeProgram);\n      }\n    }\n\n    class Program {\n      constructor(vertexShader, fragmentShader) {\n        this.uniforms = {};\n        this.program = createProgram(vertexShader, fragmentShader);\n        this.uniforms = getUniforms(this.program);\n      }\n      bind() {\n        gl.useProgram(this.program);\n      }\n    }\n\n    function createProgram(vertexShader, fragmentShader) {\n      let program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n        console.trace(gl.getProgramInfoLog(program));\n      return program;\n    }\n\n    function getUniforms(program) {\n      let uniforms = [];\n      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        let uniformName = gl.getActiveUniform(program, i).name;\n        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n      }\n      return uniforms;\n    }\n\n    function compileShader(type, source, keywords) {\n      source = addKeywords(source, keywords);\n      const shader = gl.createShader(type);\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n        console.trace(gl.getShaderInfoLog(shader));\n      return shader;\n    }\n\n    function addKeywords(source, keywords) {\n      if (!keywords) return source;\n      let keywordsString = \"\";\n      keywords.forEach((keyword) => {\n        keywordsString += \"#define \" + keyword + \"\\n\";\n      });\n      return keywordsString + source;\n    }\n\n    const baseVertexShader = compileShader(\n      gl.VERTEX_SHADER,\n      `\n        precision highp float;\n        attribute vec2 aPosition;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform vec2 texelSize;\n\n        void main () {\n            vUv = aPosition * 0.5 + 0.5;\n            vL = vUv - vec2(texelSize.x, 0.0);\n            vR = vUv + vec2(texelSize.x, 0.0);\n            vT = vUv + vec2(0.0, texelSize.y);\n            vB = vUv - vec2(0.0, texelSize.y);\n            gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const copyShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n\n        void main () {\n            gl_FragColor = texture2D(uTexture, vUv);\n        }\n      `,\n    );\n\n    const clearShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        uniform sampler2D uTexture;\n        uniform float value;\n\n        void main () {\n            gl_FragColor = value * texture2D(uTexture, vUv);\n        }\n     `,\n    );\n\n    const displayShaderSource = `\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    `;\n\n    const splatShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uTarget;\n        uniform float aspectRatio;\n        uniform vec3 color;\n        uniform vec2 point;\n        uniform float radius;\n\n        void main () {\n            vec2 p = vUv - point.xy;\n            p.x *= aspectRatio;\n            vec3 splat = exp(-dot(p, p) / radius) * color;\n            vec3 base = texture2D(uTarget, vUv).xyz;\n            gl_FragColor = vec4(base + splat, 1.0);\n        }\n      `,\n    );\n\n    const advectionShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uSource;\n        uniform vec2 texelSize;\n        uniform vec2 dyeTexelSize;\n        uniform float dt;\n        uniform float dissipation;\n\n        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n            vec2 st = uv / tsize - 0.5;\n            vec2 iuv = floor(st);\n            vec2 fuv = fract(st);\n\n            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n        }\n\n        void main () {\n            #ifdef MANUAL_FILTERING\n                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n            #else\n                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n                vec4 result = texture2D(uSource, coord);\n            #endif\n            float decay = 1.0 + dissipation * dt;\n            gl_FragColor = result / decay;\n        }\n      `,\n      ext.supportLinearFiltering ? null : [\"MANUAL_FILTERING\"],\n    );\n\n    const divergenceShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).x;\n            float R = texture2D(uVelocity, vR).x;\n            float T = texture2D(uVelocity, vT).y;\n            float B = texture2D(uVelocity, vB).y;\n\n            vec2 C = texture2D(uVelocity, vUv).xy;\n            if (vL.x < 0.0) { L = -C.x; }\n            if (vR.x > 1.0) { R = -C.x; }\n            if (vT.y > 1.0) { T = -C.y; }\n            if (vB.y < 0.0) { B = -C.y; }\n\n            float div = 0.5 * (R - L + T - B);\n            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const curlShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uVelocity, vL).y;\n            float R = texture2D(uVelocity, vR).y;\n            float T = texture2D(uVelocity, vT).x;\n            float B = texture2D(uVelocity, vB).x;\n            float vorticity = R - L - T + B;\n            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const vorticityShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision highp float;\n        precision highp sampler2D;\n        varying vec2 vUv;\n        varying vec2 vL;\n        varying vec2 vR;\n        varying vec2 vT;\n        varying vec2 vB;\n        uniform sampler2D uVelocity;\n        uniform sampler2D uCurl;\n        uniform float curl;\n        uniform float dt;\n\n        void main () {\n            float L = texture2D(uCurl, vL).x;\n            float R = texture2D(uCurl, vR).x;\n            float T = texture2D(uCurl, vT).x;\n            float B = texture2D(uCurl, vB).x;\n            float C = texture2D(uCurl, vUv).x;\n\n            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n            force /= length(force) + 0.0001;\n            force *= curl * C;\n            force.y *= -1.0;\n\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity += force * dt;\n            velocity = min(max(velocity, -1000.0), 1000.0);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const pressureShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uDivergence;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            float C = texture2D(uPressure, vUv).x;\n            float divergence = texture2D(uDivergence, vUv).x;\n            float pressure = (L + R + B + T - divergence) * 0.25;\n            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const gradientSubtractShader = compileShader(\n      gl.FRAGMENT_SHADER,\n      `\n        precision mediump float;\n        precision mediump sampler2D;\n        varying highp vec2 vUv;\n        varying highp vec2 vL;\n        varying highp vec2 vR;\n        varying highp vec2 vT;\n        varying highp vec2 vB;\n        uniform sampler2D uPressure;\n        uniform sampler2D uVelocity;\n\n        void main () {\n            float L = texture2D(uPressure, vL).x;\n            float R = texture2D(uPressure, vR).x;\n            float T = texture2D(uPressure, vT).x;\n            float B = texture2D(uPressure, vB).x;\n            vec2 velocity = texture2D(uVelocity, vUv).xy;\n            velocity.xy -= vec2(R - L, T - B);\n            gl_FragColor = vec4(velocity, 0.0, 1.0);\n        }\n      `,\n    );\n\n    const blit = (() => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(\n        gl.ARRAY_BUFFER,\n        new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),\n        gl.STATIC_DRAW,\n      );\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n      gl.bufferData(\n        gl.ELEMENT_ARRAY_BUFFER,\n        new Uint16Array([0, 1, 2, 0, 2, 3]),\n        gl.STATIC_DRAW,\n      );\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      return (target, clear = false) => {\n        if (target == null) {\n          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        } else {\n          gl.viewport(0, 0, target.width, target.height);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n        }\n        if (clear) {\n          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      };\n    })();\n\n    let dye, velocity, divergence, curl, pressure;\n\n    const copyProgram = new Program(baseVertexShader, copyShader);\n    const clearProgram = new Program(baseVertexShader, clearShader);\n    const splatProgram = new Program(baseVertexShader, splatShader);\n    const advectionProgram = new Program(baseVertexShader, advectionShader);\n    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n    const curlProgram = new Program(baseVertexShader, curlShader);\n    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n    const pressureProgram = new Program(baseVertexShader, pressureShader);\n    const gradienSubtractProgram = new Program(\n      baseVertexShader,\n      gradientSubtractShader,\n    );\n    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n\n    function initFramebuffers() {\n      let simRes = getResolution(config.SIM_RESOLUTION);\n      let dyeRes = getResolution(config.DYE_RESOLUTION);\n      const texType = ext.halfFloatTexType;\n      const rgba = ext.formatRGBA;\n      const rg = ext.formatRG;\n      const r = ext.formatR;\n      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n      gl.disable(gl.BLEND);\n\n      if (!dye)\n        dye = createDoubleFBO(\n          dyeRes.width,\n          dyeRes.height,\n          rgba.internalFormat,\n          rgba.format,\n          texType,\n          filtering,\n        );\n      else\n        dye = resizeDoubleFBO(\n          dye,\n          dyeRes.width,\n          dyeRes.height,\n          rgba.internalFormat,\n          rgba.format,\n          texType,\n          filtering,\n        );\n\n      if (!velocity)\n        velocity = createDoubleFBO(\n          simRes.width,\n          simRes.height,\n          rg.internalFormat,\n          rg.format,\n          texType,\n          filtering,\n        );\n      else\n        velocity = resizeDoubleFBO(\n          velocity,\n          simRes.width,\n          simRes.height,\n          rg.internalFormat,\n          rg.format,\n          texType,\n          filtering,\n        );\n\n      divergence = createFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST,\n      );\n      curl = createFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST,\n      );\n      pressure = createDoubleFBO(\n        simRes.width,\n        simRes.height,\n        r.internalFormat,\n        r.format,\n        texType,\n        gl.NEAREST,\n      );\n    }\n\n    function createFBO(w, h, internalFormat, format, type, param) {\n      gl.activeTexture(gl.TEXTURE0);\n      let texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        internalFormat,\n        w,\n        h,\n        0,\n        format,\n        type,\n        null,\n      );\n\n      let fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        texture,\n        0,\n      );\n      gl.viewport(0, 0, w, h);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      let texelSizeX = 1.0 / w;\n      let texelSizeY = 1.0 / h;\n      return {\n        texture,\n        fbo,\n        width: w,\n        height: h,\n        texelSizeX,\n        texelSizeY,\n        attach(id) {\n          gl.activeTexture(gl.TEXTURE0 + id);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          return id;\n        },\n      };\n    }\n\n    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n      return {\n        width: w,\n        height: h,\n        texelSizeX: fbo1.texelSizeX,\n        texelSizeY: fbo1.texelSizeY,\n        get read() {\n          return fbo1;\n        },\n        set read(value) {\n          fbo1 = value;\n        },\n        get write() {\n          return fbo2;\n        },\n        set write(value) {\n          fbo2 = value;\n        },\n        swap() {\n          let temp = fbo1;\n          fbo1 = fbo2;\n          fbo2 = temp;\n        },\n      };\n    }\n\n    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n      copyProgram.bind();\n      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n      blit(newFBO);\n      return newFBO;\n    }\n\n    function resizeDoubleFBO(\n      target,\n      w,\n      h,\n      internalFormat,\n      format,\n      type,\n      param,\n    ) {\n      if (target.width === w && target.height === h) return target;\n      target.read = resizeFBO(\n        target.read,\n        w,\n        h,\n        internalFormat,\n        format,\n        type,\n        param,\n      );\n      target.write = createFBO(w, h, internalFormat, format, type, param);\n      target.width = w;\n      target.height = h;\n      target.texelSizeX = 1.0 / w;\n      target.texelSizeY = 1.0 / h;\n      return target;\n    }\n\n    function updateKeywords() {\n      let displayKeywords = [];\n      if (config.SHADING) displayKeywords.push(\"SHADING\");\n      displayMaterial.setKeywords(displayKeywords);\n    }\n\n    updateKeywords();\n    initFramebuffers();\n    let lastUpdateTime = Date.now();\n    let colorUpdateTimer = 0.0;\n\n    function updateFrame() {\n      const dt = calcDeltaTime();\n      if (resizeCanvas()) initFramebuffers();\n      updateColors(dt);\n      applyInputs();\n      step(dt);\n      render(null);\n      requestAnimationFrame(updateFrame);\n    }\n\n    function calcDeltaTime() {\n      let now = Date.now();\n      let dt = (now - lastUpdateTime) / 1000;\n      dt = Math.min(dt, 0.016666);\n      lastUpdateTime = now;\n      return dt;\n    }\n\n    function resizeCanvas() {\n      let width = scaleByPixelRatio(canvas.clientWidth);\n      let height = scaleByPixelRatio(canvas.clientHeight);\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n\n    function updateColors(dt) {\n      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n      if (colorUpdateTimer >= 1) {\n        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n        pointers.forEach((p) => {\n          p.color = generateColor();\n        });\n      }\n    }\n\n    function applyInputs() {\n      pointers.forEach((p) => {\n        if (p.moved) {\n          p.moved = false;\n          splatPointer(p);\n        }\n      });\n    }\n\n    function step(dt) {\n      gl.disable(gl.BLEND);\n      curlProgram.bind();\n      gl.uniform2f(\n        curlProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n      blit(curl);\n\n      vorticityProgram.bind();\n      gl.uniform2f(\n        vorticityProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      gl.uniform1i(\n        vorticityProgram.uniforms.uVelocity,\n        velocity.read.attach(0),\n      );\n      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n      blit(velocity.write);\n      velocity.swap();\n\n      divergenceProgram.bind();\n      gl.uniform2f(\n        divergenceProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      gl.uniform1i(\n        divergenceProgram.uniforms.uVelocity,\n        velocity.read.attach(0),\n      );\n      blit(divergence);\n\n      clearProgram.bind();\n      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n      blit(pressure.write);\n      pressure.swap();\n\n      pressureProgram.bind();\n      gl.uniform2f(\n        pressureProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n        gl.uniform1i(\n          pressureProgram.uniforms.uPressure,\n          pressure.read.attach(1),\n        );\n        blit(pressure.write);\n        pressure.swap();\n      }\n\n      gradienSubtractProgram.bind();\n      gl.uniform2f(\n        gradienSubtractProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      gl.uniform1i(\n        gradienSubtractProgram.uniforms.uPressure,\n        pressure.read.attach(0),\n      );\n      gl.uniform1i(\n        gradienSubtractProgram.uniforms.uVelocity,\n        velocity.read.attach(1),\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      advectionProgram.bind();\n      gl.uniform2f(\n        advectionProgram.uniforms.texelSize,\n        velocity.texelSizeX,\n        velocity.texelSizeY,\n      );\n      if (!ext.supportLinearFiltering)\n        gl.uniform2f(\n          advectionProgram.uniforms.dyeTexelSize,\n          velocity.texelSizeX,\n          velocity.texelSizeY,\n        );\n      let velocityId = velocity.read.attach(0);\n      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n      gl.uniform1f(\n        advectionProgram.uniforms.dissipation,\n        config.VELOCITY_DISSIPATION,\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      if (!ext.supportLinearFiltering)\n        gl.uniform2f(\n          advectionProgram.uniforms.dyeTexelSize,\n          dye.texelSizeX,\n          dye.texelSizeY,\n        );\n      gl.uniform1i(\n        advectionProgram.uniforms.uVelocity,\n        velocity.read.attach(0),\n      );\n      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n      gl.uniform1f(\n        advectionProgram.uniforms.dissipation,\n        config.DENSITY_DISSIPATION,\n      );\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function render(target) {\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n      drawDisplay(target);\n    }\n\n    function drawDisplay(target) {\n      let width = target == null ? gl.drawingBufferWidth : target.width;\n      let height = target == null ? gl.drawingBufferHeight : target.height;\n      displayMaterial.bind();\n      if (config.SHADING)\n        gl.uniform2f(\n          displayMaterial.uniforms.texelSize,\n          1.0 / width,\n          1.0 / height,\n        );\n      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n      blit(target);\n    }\n\n    function splatPointer(pointer) {\n      let dx = pointer.deltaX * config.SPLAT_FORCE;\n      let dy = pointer.deltaY * config.SPLAT_FORCE;\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n    }\n\n    function clickSplat(pointer) {\n      const color = generateColor();\n      color.r *= 10.0;\n      color.g *= 10.0;\n      color.b *= 10.0;\n      let dx = 10 * (Math.random() - 0.5);\n      let dy = 30 * (Math.random() - 0.5);\n      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n    }\n\n    function splat(x, y, dx, dy, color) {\n      splatProgram.bind();\n      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n      gl.uniform1f(\n        splatProgram.uniforms.aspectRatio,\n        canvas.width / canvas.height,\n      );\n      gl.uniform2f(splatProgram.uniforms.point, x, y);\n      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n      gl.uniform1f(\n        splatProgram.uniforms.radius,\n        correctRadius(config.SPLAT_RADIUS / 100.0),\n      );\n      blit(velocity.write);\n      velocity.swap();\n\n      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n      blit(dye.write);\n      dye.swap();\n    }\n\n    function correctRadius(radius) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) radius *= aspectRatio;\n      return radius;\n    }\n\n    function updatePointerDownData(pointer, id, posX, posY) {\n      pointer.id = id;\n      pointer.down = true;\n      pointer.moved = false;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.deltaX = 0;\n      pointer.deltaY = 0;\n      pointer.color = generateColor();\n    }\n\n    function updatePointerMoveData(pointer, posX, posY, color) {\n      pointer.prevTexcoordX = pointer.texcoordX;\n      pointer.prevTexcoordY = pointer.texcoordY;\n      pointer.texcoordX = posX / canvas.width;\n      pointer.texcoordY = 1.0 - posY / canvas.height;\n      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n      pointer.moved =\n        Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n      pointer.color = color;\n    }\n\n    function updatePointerUpData(pointer) {\n      pointer.down = false;\n    }\n\n    function correctDeltaX(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio < 1) delta *= aspectRatio;\n      return delta;\n    }\n\n    function correctDeltaY(delta) {\n      let aspectRatio = canvas.width / canvas.height;\n      if (aspectRatio > 1) delta /= aspectRatio;\n      return delta;\n    }\n\n    function generateColor() {\n      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n      c.r *= 0.15;\n      c.g *= 0.15;\n      c.b *= 0.15;\n      return c;\n    }\n\n    function HSVtoRGB(h, s, v) {\n      let r, g, b, i, f, p, q, t;\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n          break;\n        default:\n          break;\n      }\n      return { r, g, b };\n    }\n\n    function wrap(value, min, max) {\n      const range = max - min;\n      if (range === 0) return min;\n      return ((value - min) % range) + min;\n    }\n\n    function getResolution(resolution) {\n      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n      const min = Math.round(resolution);\n      const max = Math.round(resolution * aspectRatio);\n      if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n        return { width: max, height: min };\n      else return { width: min, height: max };\n    }\n\n    function scaleByPixelRatio(input) {\n      const pixelRatio = window.devicePixelRatio || 1;\n      return Math.floor(input * pixelRatio);\n    }\n\n    function hashCode(s) {\n      if (s.length === 0) return 0;\n      let hash = 0;\n      for (let i = 0; i < s.length; i++) {\n        hash = (hash << 5) - hash + s.charCodeAt(i);\n        hash |= 0;\n      }\n      return hash;\n    }\n\n    window.addEventListener(\"mousedown\", (e) => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      updatePointerDownData(pointer, -1, posX, posY);\n      clickSplat(pointer);\n    });\n\n    document.body.addEventListener(\n      \"mousemove\",\n      function handleFirstMouseMove(e) {\n        let pointer = pointers[0];\n        let posX = scaleByPixelRatio(e.clientX);\n        let posY = scaleByPixelRatio(e.clientY);\n        let color = generateColor();\n        updateFrame();\n        updatePointerMoveData(pointer, posX, posY, color);\n        document.body.removeEventListener(\"mousemove\", handleFirstMouseMove);\n      },\n    );\n\n    window.addEventListener(\"mousemove\", (e) => {\n      let pointer = pointers[0];\n      let posX = scaleByPixelRatio(e.clientX);\n      let posY = scaleByPixelRatio(e.clientY);\n      let color = pointer.color;\n      updatePointerMoveData(pointer, posX, posY, color);\n    });\n\n    document.body.addEventListener(\n      \"touchstart\",\n      function handleFirstTouchStart(e) {\n        const touches = e.targetTouches;\n        let pointer = pointers[0];\n        for (let i = 0; i < touches.length; i++) {\n          let posX = scaleByPixelRatio(touches[i].clientX);\n          let posY = scaleByPixelRatio(touches[i].clientY);\n          updateFrame();\n          updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n        }\n        document.body.removeEventListener(\"touchstart\", handleFirstTouchStart);\n      },\n    );\n\n    window.addEventListener(\"touchstart\", (e) => {\n      const touches = e.targetTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        let posX = scaleByPixelRatio(touches[i].clientX);\n        let posY = scaleByPixelRatio(touches[i].clientY);\n        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n      }\n    });\n\n    window.addEventListener(\n      \"touchmove\",\n      (e) => {\n        const touches = e.targetTouches;\n        let pointer = pointers[0];\n        for (let i = 0; i < touches.length; i++) {\n          let posX = scaleByPixelRatio(touches[i].clientX);\n          let posY = scaleByPixelRatio(touches[i].clientY);\n          updatePointerMoveData(pointer, posX, posY, pointer.color);\n        }\n      },\n      false,\n    );\n\n    window.addEventListener(\"touchend\", (e) => {\n      const touches = e.changedTouches;\n      let pointer = pointers[0];\n      for (let i = 0; i < touches.length; i++) {\n        updatePointerUpData(pointer);\n      }\n    });\n\n    updateFrame();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    SIM_RESOLUTION,\n    DYE_RESOLUTION,\n    CAPTURE_RESOLUTION,\n    DENSITY_DISSIPATION,\n    VELOCITY_DISSIPATION,\n    PRESSURE,\n    PRESSURE_ITERATIONS,\n    CURL,\n    SPLAT_RADIUS,\n    SPLAT_FORCE,\n    SHADING,\n    COLOR_UPDATE_SPEED,\n    BACK_COLOR,\n    TRANSPARENT,\n  ]);\n\n  return (\n    <div className=\"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\">\n      <canvas\n        ref={canvasRef}\n        id=\"fluid\"\n        className=\"w-screen h-screen block\"\n      ></canvas>\n    </div>\n  );\n}\n\nexport default SplashCursor;\n"],"mappings":"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AAE3B,QAAQ,EAAE;MACrC,IAAI,CAACA,QAAQ,EAAE,OAAO2B,MAAM;MAC5B,IAAIQ,cAAc,GAAG,EAAE;MACvBnC,QAAQ,CAACoC,OAAO,CAAEC,OAAO,IAAK;QAC5BF,cAAc,IAAI,UAAU,GAAGE,OAAO,GAAG,IAAI;MAC/C,CAAC,CAAC;MACF,OAAOF,cAAc,GAAGR,MAAM;IAChC;IAEA,MAAMW,gBAAgB,GAAG/B,aAAa,CACpCpE,EAAE,CAACoG,aAAa,EAChB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMC,UAAU,GAAGjC,aAAa,CAC9BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMiC,WAAW,GAAGlC,aAAa,CAC/BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MACI,CAAC;IAED,MAAMkC,mBAAmB,GAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;IAED,MAAMC,WAAW,GAAGpC,aAAa,CAC/BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMoC,eAAe,GAAGrC,aAAa,CACnCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EACDpE,GAAG,CAACE,sBAAsB,GAAG,IAAI,GAAG,CAAC,kBAAkB,CACzD,CAAC;IAED,MAAMuG,gBAAgB,GAAGtC,aAAa,CACpCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMsC,UAAU,GAAGvC,aAAa,CAC9BpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMuC,eAAe,GAAGxC,aAAa,CACnCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMwC,cAAc,GAAGzC,aAAa,CAClCpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAMyC,sBAAsB,GAAG1C,aAAa,CAC1CpE,EAAE,CAACqE,eAAe,EAClB;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IAED,MAAM0C,IAAI,GAAG,CAAC,MAAM;MAClB/G,EAAE,CAACgH,UAAU,CAAChH,EAAE,CAACiH,YAAY,EAAEjH,EAAE,CAACkH,YAAY,CAAC,CAAC,CAAC;MACjDlH,EAAE,CAACmH,UAAU,CACXnH,EAAE,CAACiH,YAAY,EACf,IAAIG,YAAY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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}